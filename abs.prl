This is intended as an attempt at converting abs.sdl to Promela
The UserControl process is basically done, but we have a problem in
mapping channels between the two languages.

/* Simple Alternating-Bit example with loopback provider */

system ab_example;

	newtype Packet 	/* Dummy data packet definition */
		array (2) of integer;
	endnewtype

	signal
		u_data_req(Packet), u_data_rsp, u_data_ind(Packet),
		p_data_req(Integer,Packet), p_data_ind(Integer,Packet),
		p_ack_req(Integer), p_ack_ind(Integer);

chan upper_Ch_u_data_
	channel upper_Ch
		from User to Protocol
			with u_data_req;
		from Protocol to User
			with u_data_ind, u_data_rsp;
	endchannel upper_Ch;

	channel lower_Ch
		from Protocol to Provider
			with p_data_req, p_ack_req;
		from Provider to Protocol
			with p_data_ind, p_ack_ind;
	endchannel lower_Ch;

	/* Provider Block */

	block Provider;
		process ProvControl referenced;
		signalroute Comm
			from ProvControl to env
				with p_data_ind, p_ack_ind;
			from env to ProvControl
				with p_data_req, p_ack_req;
		connect lower_Ch and Comm;
	endblock Provider;

	/* Protocol block */

	block Protocol;
		process ProtControl referenced;
		signalroute PComm
			from ProtControl to env
				with p_data_req, p_ack_req;
			from env to ProtControl
				with p_data_ind, p_ack_ind;
		signalroute UComm
			from env to ProtControl
				with u_data_req;
			from ProtControl to env
				with u_data_ind, u_data_rsp;
		connect lower_Ch and PComm;
		connect upper_Ch and UComm;
	endblock Protocol;

	/* User block */

	block User;
		process UserControl referenced;
		signalroute Comm
			from UserControl to env
				with u_data_req;
			from env to UserControl
				with u_data_ind, u_data_rsp;
		connect upper_Ch and Comm;
	endblock User;
endsystem ab_example;

/* Each  block has a single controlling process */

process system ab_example/block Provider ProvControl(1,1);
	dcl seq Integer;
	dcl data Packet;
	start;
		nextstate idle;
	state idle;
		input p_data_req(seq,data);
			output p_data_ind(seq,data);
			nextstate -;
		input p_ack_req(seq);
			output p_ack_ind(seq);
			nextstate -;
endprocess;

process system ab_example/block Protocol ProtControl(1,1);
	dcl sn Integer;
	dcl rn Integer;
	dcl seq Integer;
	dcl data Packet;
	dcl tm Duration := 10.;
	timer Timeout;
	start;
		task sn := 0;
		task rn := 0;
		nextstate idle;
	state idle;
		input u_data_req(data);
			write sn;
			output p_data_req(sn, data);
			set (now + tm, Timeout); 
			nextstate wait;
		input p_ack_ind(seq); /* Do nothing */
			nextstate -;
	state wait;
		input p_ack_ind(seq);
			decision seq = sn;
			( false ) : /* do nothing */
				write(2);
				nextstate -;
			( true )  :
				task sn := (sn + 1) mod 2;
				output u_data_rsp;
				reset (Timeout); 
				nextstate idle;
			enddecision;
		input Timeout;
			output p_data_req(sn, data);
			set (now + tm, Timeout); 
			nextstate -;
	state *;
		input p_data_ind(seq, data);
			decision seq = rn;
			( false ) : /* do nothing */
/*				write(seq);
				write(rn); */
			( true )  :
				output u_data_ind(data);
				output p_ack_req(rn);
				task rn := (rn + 1) mod 2;
			enddecision;
			nextstate -;
endprocess;

proctype ab_example_User_UserControl()
{
	int data[2];
	int delayWait = 3.;
	int counter = 0;
	int sendDelay = 0;
start:
	goto sendfirst;
sendfirst:
	data[0] = counter;
	data[1] = counter+1;
	?? !u_data_req(data);
	goto idle;
idle:
	if 
	:: ?? ?u_data_rsp -> { sendDelay = 1; goto idle }
	:: ?? ?u_data_ind(data) -> goto idle
	:: (timeout && sendDelay) -> {
			counter= counter+1;
			data(0) = counter;
			data(1) = counter+1;
			!u_data_req(data);
			sendDelay = 0;
			goto idle;
		}
	fi
}

init
{
	/* create a proctype ab_example_User_UserControl */
}
